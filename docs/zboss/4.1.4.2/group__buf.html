<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Developing with ZBOSS for Zigbee : Packet buffers pool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Developing with ZBOSS for Zigbee
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__buf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Packet buffers pool<div class="ingroups"><a class="el" href="group__api__zb.html">Zigbee stack API</a> &raquo; <a class="el" href="group__ll.html">ZBOSS framework</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzb__buf__hdr__s.html">zb_buf_hdr_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzb__mult__buf__s.html">zb_mult_buf_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzb__leg__buf__s.html">zb_leg_buf_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8af8aea1a25b9c80d415eaac1e315376"><td class="memItemLeft" align="right" valign="top"><a id="ga8af8aea1a25b9c80d415eaac1e315376"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_RESERVED_BUF_TO_ALIGN_HDR_SIZE</b>&#160;&#160;&#160;1u</td></tr>
<tr class="separator:ga8af8aea1a25b9c80d415eaac1e315376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00a717864f97eb2e8773581ede3f70f"><td class="memItemLeft" align="right" valign="top"><a id="gae00a717864f97eb2e8773581ede3f70f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_BUF_INVALID</b>&#160;&#160;&#160;0U</td></tr>
<tr class="separator:gae00a717864f97eb2e8773581ede3f70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6291647fe8456972f6f68c7013d9be1"><td class="memItemLeft" align="right" valign="top"><a id="gaf6291647fe8456972f6f68c7013d9be1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_UNDEFINED_BUFFER</b>&#160;&#160;&#160;0U</td></tr>
<tr class="separator:gaf6291647fe8456972f6f68c7013d9be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a4c72dd48bd02030b1a96e77a6990fa"><td class="memItemLeft" align="right" valign="top"><a id="ga7a4c72dd48bd02030b1a96e77a6990fa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRACE_PROTO_VOID</b>&#160;&#160;&#160;void</td></tr>
<tr class="separator:ga7a4c72dd48bd02030b1a96e77a6990fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee83771fef82266f2774784a71a0016e"><td class="memItemLeft" align="right" valign="top"><a id="gaee83771fef82266f2774784a71a0016e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRACE_PROTO</b></td></tr>
<tr class="separator:gaee83771fef82266f2774784a71a0016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f793d46154f5033a737488324e7f4a"><td class="memItemLeft" align="right" valign="top"><a id="ga76f793d46154f5033a737488324e7f4a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRACE_CALL_VOID</b></td></tr>
<tr class="separator:ga76f793d46154f5033a737488324e7f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3a280bd78a335d8c01d645b253c959"><td class="memItemLeft" align="right" valign="top"><a id="ga7f3a280bd78a335d8c01d645b253c959"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRACE_CALL</b></td></tr>
<tr class="separator:ga7f3a280bd78a335d8c01d645b253c959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8730e62084a896bc550773a8e03a43ca"><td class="memItemLeft" align="right" valign="top"><a id="ga8730e62084a896bc550773a8e03a43ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_TRACE_BUFS_USAGE</b>()</td></tr>
<tr class="separator:ga8730e62084a896bc550773a8e03a43ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252f09a403d23347b2d4987a4d8d1833"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga252f09a403d23347b2d4987a4d8d1833">zb_buf_get</a>(is_in,  max_size)&#160;&#160;&#160;zb_buf_get_func(TRACE_CALL (is_in), (max_size))</td></tr>
<tr class="separator:ga252f09a403d23347b2d4987a4d8d1833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1837a0e5af1ed402ca3b84d526f4856b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga1837a0e5af1ed402ca3b84d526f4856b">zb_buf_get_out</a>()&#160;&#160;&#160;zb_buf_get_out_func(TRACE_CALL_VOID)</td></tr>
<tr class="separator:ga1837a0e5af1ed402ca3b84d526f4856b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480eed47d5b538029aefd501e011d97e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga480eed47d5b538029aefd501e011d97e">zb_buf_get_any</a>()&#160;&#160;&#160;zb_buf_get_any_func(TRACE_CALL_VOID)</td></tr>
<tr class="separator:ga480eed47d5b538029aefd501e011d97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad941f68ff2866420c96548c426e085f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gad941f68ff2866420c96548c426e085f5">zb_buf_get_hipri</a>(a)&#160;&#160;&#160;zb_buf_get_hipri_func(TRACE_CALL (a))</td></tr>
<tr class="separator:gad941f68ff2866420c96548c426e085f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd34d85cc79b8c0712f69cd4a86ed392"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gabd34d85cc79b8c0712f69cd4a86ed392">zb_buf_get_max_size</a>(a)&#160;&#160;&#160;zb_buf_get_max_size_func(TRACE_CALL (a))</td></tr>
<tr class="separator:gabd34d85cc79b8c0712f69cd4a86ed392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284f25d25ef8a911d00dc79bea80ce42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga284f25d25ef8a911d00dc79bea80ce42">zb_buf_get_out_delayed</a>(callback)&#160;&#160;&#160;zb_buf_get_out_delayed_func(TRACE_CALL (callback))</td></tr>
<tr class="memdesc:ga284f25d25ef8a911d00dc79bea80ce42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate OUT buffer, call a callback when the buffer is available.  <a href="group__buf.html#ga284f25d25ef8a911d00dc79bea80ce42">More...</a><br /></td></tr>
<tr class="separator:ga284f25d25ef8a911d00dc79bea80ce42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0f373a65f012c04317b6a602823e2aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gad0f373a65f012c04317b6a602823e2aa">zb_buf_get_in_delayed</a>(callback)&#160;&#160;&#160;zb_buf_get_in_delayed_func(TRACE_CALL (callback))</td></tr>
<tr class="memdesc:gad0f373a65f012c04317b6a602823e2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate IN buffer, call a callback when the buffer is available.  <a href="group__buf.html#gad0f373a65f012c04317b6a602823e2aa">More...</a><br /></td></tr>
<tr class="separator:gad0f373a65f012c04317b6a602823e2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1aadf51fc1f01efe2663c442bc1a73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga3e1aadf51fc1f01efe2663c442bc1a73">zb_buf_get_out_delayed_ext</a>(callback,  arg,  max_size)&#160;&#160;&#160;zb_buf_get_out_delayed_ext_func(TRACE_CALL (callback),(arg),(max_size))</td></tr>
<tr class="memdesc:ga3e1aadf51fc1f01efe2663c442bc1a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate OUT buffer, call a callback when the buffer is available.  <a href="group__buf.html#ga3e1aadf51fc1f01efe2663c442bc1a73">More...</a><br /></td></tr>
<tr class="separator:ga3e1aadf51fc1f01efe2663c442bc1a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca8f9478335d866bc798676906f18f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga2ca8f9478335d866bc798676906f18f0">zb_buf_get_in_delayed_ext</a>(callback,  arg,  max_size)&#160;&#160;&#160;zb_buf_get_in_delayed_ext_func(TRACE_CALL (callback),(arg),(max_size))</td></tr>
<tr class="memdesc:ga2ca8f9478335d866bc798676906f18f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate IN buffer, call a callback when the buffer is available.  <a href="group__buf.html#ga2ca8f9478335d866bc798676906f18f0">More...</a><br /></td></tr>
<tr class="separator:ga2ca8f9478335d866bc798676906f18f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788a473df6d535c19f5da0d142d4fa01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga788a473df6d535c19f5da0d142d4fa01">zb_buf_free</a>(buf)&#160;&#160;&#160;zb_buf_free_func(TRACE_CALL (buf))</td></tr>
<tr class="memdesc:ga788a473df6d535c19f5da0d142d4fa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free packet buffer and put it into free list.  <a href="group__buf.html#ga788a473df6d535c19f5da0d142d4fa01">More...</a><br /></td></tr>
<tr class="separator:ga788a473df6d535c19f5da0d142d4fa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97fe9fcc0124718cc25c3710b752b8fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga97fe9fcc0124718cc25c3710b752b8fd">zb_buf_begin</a>(buf)&#160;&#160;&#160;zb_buf_begin_func(TRACE_CALL (buf))</td></tr>
<tr class="separator:ga97fe9fcc0124718cc25c3710b752b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c884c4d660daa357eb208ca010e9e56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga4c884c4d660daa357eb208ca010e9e56">zb_buf_end</a>(buf)&#160;&#160;&#160;zb_buf_end_func(TRACE_CALL (buf))</td></tr>
<tr class="separator:ga4c884c4d660daa357eb208ca010e9e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c187cf4fb6d5edbbb400bff57f6073e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga4c187cf4fb6d5edbbb400bff57f6073e">zb_buf_len</a>(buf)&#160;&#160;&#160;zb_buf_len_func(TRACE_CALL (buf))</td></tr>
<tr class="separator:ga4c187cf4fb6d5edbbb400bff57f6073e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191c257839a606771135a63f5eafd8a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga191c257839a606771135a63f5eafd8a0">zb_buf_copy</a>(dst_buf,  src_buf)&#160;&#160;&#160;zb_buf_copy_func(TRACE_CALL (dst_buf),(src_buf))</td></tr>
<tr class="separator:ga191c257839a606771135a63f5eafd8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71af155e981aa06d5a56db6b46d8cc7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga71af155e981aa06d5a56db6b46d8cc7c">zb_buf_initial_alloc</a>(buf,  size)&#160;&#160;&#160;zb_buf_initial_alloc_func(TRACE_CALL (buf),(size))</td></tr>
<tr class="memdesc:ga71af155e981aa06d5a56db6b46d8cc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial data space allocation in buffer.  <a href="group__buf.html#ga71af155e981aa06d5a56db6b46d8cc7c">More...</a><br /></td></tr>
<tr class="separator:ga71af155e981aa06d5a56db6b46d8cc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f7d1e99e61284da1fa3ddb7f725450"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga15f7d1e99e61284da1fa3ddb7f725450">zb_buf_reuse</a>(buf)&#160;&#160;&#160;zb_buf_reuse_func(TRACE_CALL (buf))</td></tr>
<tr class="separator:ga15f7d1e99e61284da1fa3ddb7f725450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac17ca5d2b3c60c0fb413fa783b6f3d38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gac17ca5d2b3c60c0fb413fa783b6f3d38">zb_buf_alloc_tail</a>(buf,  size)&#160;&#160;&#160;zb_buf_alloc_tail_func(TRACE_CALL (buf),(size))</td></tr>
<tr class="separator:gac17ca5d2b3c60c0fb413fa783b6f3d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2b3e1cb6505be4c03235fc5467ebdf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga3b2b3e1cb6505be4c03235fc5467ebdf">zb_buf_get_tail</a>(buf,  size)&#160;&#160;&#160;zb_buf_get_tail_func(TRACE_CALL (buf),(size))</td></tr>
<tr class="separator:ga3b2b3e1cb6505be4c03235fc5467ebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e0718a3bb63059a2626ac98b54d65d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gaf7e0718a3bb63059a2626ac98b54d65d">ZB_BUF_GET_PARAM</a>(buf,  type)&#160;&#160;&#160;((type *)zb_buf_get_tail_func(TRACE_CALL (buf), sizeof(type)))</td></tr>
<tr class="separator:gaf7e0718a3bb63059a2626ac98b54d65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68fc67e31e64f6549df59ae20ac0af3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga68fc67e31e64f6549df59ae20ac0af3e">zb_buf_cut_right</a>(buf,  size)&#160;&#160;&#160;zb_buf_cut_right_func(TRACE_CALL (buf),(size))</td></tr>
<tr class="separator:ga68fc67e31e64f6549df59ae20ac0af3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a650530bd2e6d2486a5017b885ff292"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga1a650530bd2e6d2486a5017b885ff292">zb_buf_cut_left</a>(buf,  size)&#160;&#160;&#160;zb_buf_cut_left_func(TRACE_CALL (buf),(size))</td></tr>
<tr class="separator:ga1a650530bd2e6d2486a5017b885ff292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3be3fececb70e81b7541a47e915fafc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga3be3fececb70e81b7541a47e915fafc2">zb_buf_alloc_right</a>(buf,  size)&#160;&#160;&#160;zb_buf_alloc_right_func(TRACE_CALL (buf),(size))</td></tr>
<tr class="separator:ga3be3fececb70e81b7541a47e915fafc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04531caf208df1bd8cc5cc920382f85"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gaa04531caf208df1bd8cc5cc920382f85">zb_buf_alloc_left</a>(buf,  size)&#160;&#160;&#160;zb_buf_alloc_left_func(TRACE_CALL (buf),(size))</td></tr>
<tr class="separator:gaa04531caf208df1bd8cc5cc920382f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c8cb7cd6d9de2c9463640086558864"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga15c8cb7cd6d9de2c9463640086558864">zb_buf_flags_or</a>(buf,  val)&#160;&#160;&#160;zb_buf_flags_or_func(TRACE_CALL (buf),(val))</td></tr>
<tr class="separator:ga15c8cb7cd6d9de2c9463640086558864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b2d67c201a1d1712d29eee6cc40541"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gaf1b2d67c201a1d1712d29eee6cc40541">zb_buf_flags_clr</a>(buf,  mask)&#160;&#160;&#160;zb_buf_flags_clr_func(TRACE_CALL (buf),(mask))</td></tr>
<tr class="separator:gaf1b2d67c201a1d1712d29eee6cc40541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa797eb92f12ff524afbf944be0b70db0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gaa797eb92f12ff524afbf944be0b70db0">zb_buf_flags_clr_encr</a>(buf)&#160;&#160;&#160;zb_buf_flags_clr_encr_func(TRACE_CALL (buf))</td></tr>
<tr class="separator:gaa797eb92f12ff524afbf944be0b70db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0adf98232d17ed70ea6c38e545d97fa2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga0adf98232d17ed70ea6c38e545d97fa2">zb_buf_flags_get</a>(buf)&#160;&#160;&#160;zb_buf_flags_get_func(TRACE_CALL (buf))</td></tr>
<tr class="separator:ga0adf98232d17ed70ea6c38e545d97fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17d85461a3ccc58a225d62a0b80affab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga17d85461a3ccc58a225d62a0b80affab">zb_buf_get_status</a>(buf)&#160;&#160;&#160;zb_buf_get_status_func(TRACE_CALL (buf))</td></tr>
<tr class="separator:ga17d85461a3ccc58a225d62a0b80affab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4304fbb18c02bd1a2a3e385e1e9c5bfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga4304fbb18c02bd1a2a3e385e1e9c5bfb">zb_buf_set_status</a>(buf,  status)&#160;&#160;&#160;zb_buf_set_status_func(TRACE_CALL (buf), (<a class="el" href="group__base__types.html#ga7bdda62719777b9e47b1d7204669f897">zb_ret_t</a>)(status))</td></tr>
<tr class="separator:ga4304fbb18c02bd1a2a3e385e1e9c5bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafb1da2b85a931aa24a6c5272359baf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gaafb1da2b85a931aa24a6c5272359baf4">zb_buf_get_handle</a>(buf)&#160;&#160;&#160;zb_buf_get_handle_func(TRACE_CALL (buf))</td></tr>
<tr class="separator:gaafb1da2b85a931aa24a6c5272359baf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4efecce2b42165387bb6672ad51423"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga7d4efecce2b42165387bb6672ad51423">zb_buf_set_handle</a>(buf,  handle)&#160;&#160;&#160;zb_buf_set_handle_func(TRACE_CALL (buf),(handle))</td></tr>
<tr class="separator:ga7d4efecce2b42165387bb6672ad51423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14b3e06193b3dfc9da25717294bc60d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_BUF_COPY_FLAG_APS_PAYLOAD</b>(dst,  src)</td></tr>
<tr class="separator:gaa14b3e06193b3dfc9da25717294bc60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3c4203d3a3dff809f0261423f7ff0c5b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structzb__buf__hdr__s.html">zb_buf_hdr_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga3c4203d3a3dff809f0261423f7ff0c5b">zb_buf_hdr_t</a></td></tr>
<tr class="separator:ga3c4203d3a3dff809f0261423f7ff0c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276d630a0f90931f8110e7b8e7a45df7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structzb__mult__buf__s.html">zb_mult_buf_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga276d630a0f90931f8110e7b8e7a45df7">zb_mult_buf_t</a></td></tr>
<tr class="separator:ga276d630a0f90931f8110e7b8e7a45df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7bf548ce24f125321f00242d98d7fa"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structzb__leg__buf__s.html">zb_leg_buf_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gaed7bf548ce24f125321f00242d98d7fa">zb_leg_buf_t</a></td></tr>
<tr class="separator:gaed7bf548ce24f125321f00242d98d7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d6df348d96d2ce8bfeb8d3bdda764b"><td class="memItemLeft" align="right" valign="top"><a id="ga54d6df348d96d2ce8bfeb8d3bdda764b"></a>
typedef <a class="el" href="group__buf.html#ga276d630a0f90931f8110e7b8e7a45df7">zb_mult_buf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>zb_buf_ent_t</b></td></tr>
<tr class="separator:ga54d6df348d96d2ce8bfeb8d3bdda764b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4388a287d60e2916569ebe70c16a6ddf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__base__types.html#gaa82a9657ef11a3947586065cf8066256">zb_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga4388a287d60e2916569ebe70c16a6ddf">zb_buffer_types_t</a></td></tr>
<tr class="memdesc:ga4388a287d60e2916569ebe70c16a6ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for Buffer type (direction).  <a href="group__buf.html#ga4388a287d60e2916569ebe70c16a6ddf">More...</a><br /></td></tr>
<tr class="separator:ga4388a287d60e2916569ebe70c16a6ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72fb48e56b8e7f4b0cf12d12bd491b3b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__base__types.html#gaa82a9657ef11a3947586065cf8066256">zb_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga72fb48e56b8e7f4b0cf12d12bd491b3b">zb_bufid_t</a></td></tr>
<tr class="separator:ga72fb48e56b8e7f4b0cf12d12bd491b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4590df4d3fd9b8f78d33ad87279b8d8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__base__types.html#gaa82a9657ef11a3947586065cf8066256">zb_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gab4590df4d3fd9b8f78d33ad87279b8d8">zb_buf_flags_bm_t</a></td></tr>
<tr class="memdesc:gab4590df4d3fd9b8f78d33ad87279b8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for buffer's internals flags bitmask.  <a href="group__buf.html#gab4590df4d3fd9b8f78d33ad87279b8d8">More...</a><br /></td></tr>
<tr class="separator:gab4590df4d3fd9b8f78d33ad87279b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga07e654211600559e899f0dfee4a3b9bb"><td class="memItemLeft" align="right" valign="top"><a id="ga07e654211600559e899f0dfee4a3b9bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_ASSERT_COMPILE_DECL</b> ((sizeof(<a class="el" href="group__buf.html#ga3c4203d3a3dff809f0261423f7ff0c5b">zb_buf_hdr_t</a>) % sizeof(<a class="el" href="group__base__types.html#ga964947a10fa0ad0bd6df7bd91ecfac9c">zb_uint32_t</a>))==0)</td></tr>
<tr class="separator:ga07e654211600559e899f0dfee4a3b9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94c767c6511e373274b416ff4d212fa7"><td class="memItemLeft" align="right" valign="top"><a id="ga94c767c6511e373274b416ff4d212fa7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_ASSERT_COMPILE_DECL</b> ((ZB_OFFSETOF(<a class="el" href="group__buf.html#ga276d630a0f90931f8110e7b8e7a45df7">zb_mult_buf_t</a>, buf) % sizeof(<a class="el" href="group__base__types.html#ga964947a10fa0ad0bd6df7bd91ecfac9c">zb_uint32_t</a>))==0)</td></tr>
<tr class="separator:ga94c767c6511e373274b416ff4d212fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7855cad80be48f2feac0f61eb53cf27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gad7855cad80be48f2feac0f61eb53cf27">zb_buf_is_oom_state</a> (void)</td></tr>
<tr class="separator:gad7855cad80be48f2feac0f61eb53cf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390b0c8500e8d2ac8885ffdfe97493d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga390b0c8500e8d2ac8885ffdfe97493d6">zb_buf_oom_trace</a> (void)</td></tr>
<tr class="separator:ga390b0c8500e8d2ac8885ffdfe97493d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8ad9f761a1eccf00ab3eb761a55c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga9e8ad9f761a1eccf00ab3eb761a55c7e">zb_buf_memory_low</a> (void)</td></tr>
<tr class="separator:ga9e8ad9f761a1eccf00ab3eb761a55c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f8ca54988786ec13015435abae6f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga98f8ca54988786ec13015435abae6f9e">zb_buf_set_mac_rx_need</a> (<a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a> needs)</td></tr>
<tr class="separator:ga98f8ca54988786ec13015435abae6f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9221bc9089fcd4be96a28944d0e82d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gae9221bc9089fcd4be96a28944d0e82d2">zb_buf_get_mac_rx_need</a> (void)</td></tr>
<tr class="separator:gae9221bc9089fcd4be96a28944d0e82d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fea4c20527b654e7306f46a360bafea"><td class="memItemLeft" align="right" valign="top"><a id="ga4fea4c20527b654e7306f46a360bafea"></a>
<a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>zb_buf_have_rx_bufs</b> (void)</td></tr>
<tr class="separator:ga4fea4c20527b654e7306f46a360bafea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Buffer type (direction)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd0068d7d86a032d2a523e5975748cff6"></a><a class="anchor" id="buffer_types"></a></p>
</td></tr>
<tr class="memitem:ga7a7f62c75a26924133e28ea5deda3c9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga7a7f62c75a26924133e28ea5deda3c9d">ZB_OUT_BUFFER</a>&#160;&#160;&#160;0U</td></tr>
<tr class="separator:ga7a7f62c75a26924133e28ea5deda3c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b987673c0116e579f4865a328d2e26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gad2b987673c0116e579f4865a328d2e26">ZB_IN_BUFFER</a>&#160;&#160;&#160;1U</td></tr>
<tr class="separator:gad2b987673c0116e579f4865a328d2e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Buffer's internals flags bitmask</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp917cc4b034a23372b864f73bf9f11cf6"></a><a class="anchor" id="buf_flags_bm"></a></p>
</td></tr>
<tr class="memitem:ga0f85025383555d0cba148b844aca036c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga0f85025383555d0cba148b844aca036c">ZB_BUF_SECUR_NO_ENCR</a>&#160;&#160;&#160;0U</td></tr>
<tr class="separator:ga0f85025383555d0cba148b844aca036c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc4eab253c84e6144581e0943a730185"><td class="memItemLeft" align="right" valign="top"><a id="gafc4eab253c84e6144581e0943a730185"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_BUF_IS_IN</b>&#160;&#160;&#160;(1U &lt;&lt; 0)</td></tr>
<tr class="separator:gafc4eab253c84e6144581e0943a730185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d5f780deaff8d4a19dc54099fd648f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga1d5f780deaff8d4a19dc54099fd648f6">ZB_BUF_SECUR_NWK_ENCR</a>&#160;&#160;&#160;(1U &lt;&lt; 1)</td></tr>
<tr class="separator:ga1d5f780deaff8d4a19dc54099fd648f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262b53968bed3479e484f4947fed664f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga262b53968bed3479e484f4947fed664f">ZB_BUF_SECUR_APS_ENCR</a>&#160;&#160;&#160;(1U &lt;&lt; 2)</td></tr>
<tr class="separator:ga262b53968bed3479e484f4947fed664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd90dd9cc56c3c01a6b9689abb83eec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga6dd90dd9cc56c3c01a6b9689abb83eec">ZB_BUF_SECUR_MAC_ENCR</a>&#160;&#160;&#160;(1U &lt;&lt; 3)</td></tr>
<tr class="separator:ga6dd90dd9cc56c3c01a6b9689abb83eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff24c7df778c1af7b0c3598851324f5"><td class="memItemLeft" align="right" valign="top"><a id="gadff24c7df778c1af7b0c3598851324f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_BUF_SECUR_ALL_ENCR</b>&#160;&#160;&#160;(<a class="el" href="group__buf.html#ga1d5f780deaff8d4a19dc54099fd648f6">ZB_BUF_SECUR_NWK_ENCR</a> | <a class="el" href="group__buf.html#ga262b53968bed3479e484f4947fed664f">ZB_BUF_SECUR_APS_ENCR</a> | <a class="el" href="group__buf.html#ga6dd90dd9cc56c3c01a6b9689abb83eec">ZB_BUF_SECUR_MAC_ENCR</a>)</td></tr>
<tr class="separator:gadff24c7df778c1af7b0c3598851324f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b6d7217e0e0438c95bc0c469e8c2aa"><td class="memItemLeft" align="right" valign="top"><a id="ga27b6d7217e0e0438c95bc0c469e8c2aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_BUF_USE_SAME_KEY</b>&#160;&#160;&#160;(1U &lt;&lt; 4)</td></tr>
<tr class="separator:ga27b6d7217e0e0438c95bc0c469e8c2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb165c495d2a7476628940bd75815a1e"><td class="memItemLeft" align="right" valign="top"><a id="gacb165c495d2a7476628940bd75815a1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ZB_BUF_ZDO_CMD_NO_RESP</b>&#160;&#160;&#160;(1U &lt;&lt; 5)</td></tr>
<tr class="separator:gacb165c495d2a7476628940bd75815a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd3894cea7e4ef4fe70fb12f5816b20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#ga0bd3894cea7e4ef4fe70fb12f5816b20">ZB_BUF_HAS_APS_PAYLOAD</a>&#160;&#160;&#160;(1U &lt;&lt; 6)</td></tr>
<tr class="separator:ga0bd3894cea7e4ef4fe70fb12f5816b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae95514c452ade7c8854d51200e488bd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buf.html#gae95514c452ade7c8854d51200e488bd8">ZB_BUF_HAS_APS_USER_PAYLOAD</a>&#160;&#160;&#160;(1U &lt;&lt; 7)</td></tr>
<tr class="separator:gae95514c452ade7c8854d51200e488bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Packet buffers</dt><dd></dd></dl>
<p>The main idea is to be simple, CPU effective and eliminate data copy when possible (again, to decrease CPU load).</p>
<p>One of the main data structure of the ZBOSS stack is memory buffer, which is used for storing Zigbee packet. Zigbee packets has limited size (127 bytes). Zigbee packets are usually not fragmented, excluding fragmentation of big packets at APS layer. Extended buffers are used to store big packets.</p>
<p>To use extended buffers in application use <a class="el" href="group__buf.html#ga3e1aadf51fc1f01efe2663c442bc1a73">zb_buf_get_out_delayed_ext()</a> and <a class="el" href="group__buf.html#ga2ca8f9478335d866bc798676906f18f0">zb_buf_get_in_delayed_ext()</a> functions.</p>
<p>So, the same memory buffer can be used for a single packet going down-up or up-down between the user application and ZBOSS layers. Each layer or the application can modify the memory buffer: remove data partly or fully or add more data if there is free memory space in the buffer.</p>
<p>ZBOSS uses pre-defined pool of the fixed size memory buffers. The size of buffer pool can be changed, see more information about it in <a class="el" href="zigbee_mem_cfg_ram_feature.html">Memory configuration feature</a>. A memory buffer consists of a header and a data buffer of 148 bytes. An application or the stack functions can get a single memory buffer from the pool (allocate the memory buffer) when it is necessary or put the buffer back when it is not needed anymore (release the memory buffer).</p>
<p>Every buffer has a header with these header fields:</p><ul>
<li>current layer data pointer</li>
<li>current layer length</li>
<li>'status' for 'confirm' interface</li>
<li>'handle' for data and confirm interfaces</li>
<li>flags</li>
</ul>
<p>To avoid data copying, the following technique is used: when a Zigbee packet moves up between the Zigbee layers, the data related to the lower layers is removed by modifying the data pointer and data length in the buffer header. When a Zigbee packet is passing down between the Zigbee layers, the initial data is stored not from the beginning of the data buffer, but in the middle, so some space is reserved before and after the data. Therefore, if a lower Zigbee layer puts some data to a header or to a tail, data copying is generally not required. However, if there is not enough space for a header or a tail, the existing data may be moved to the right or to the left.</p>
<p>Logically, the memory buffers are divided into 2 types: for in and out packets. Thus, the buffer pool allocates both 'in' and 'out' types of buffers. This approach helps prevent allocating of all the memory buffers for incoming or outgoing packets, only those that may block ZBOSS from sending or receiving respectively any data. Obviously, such blocking may cause a scenario where it is impossible to send an acknowledgement for the received packet and the packet will be retransmitted by a remote due to the lack of the acknowledgement.</p>
<p>Memory buffers are commonly used for passing parameters to ZBOSS API functions. The following technique is used: data space needed for storing the parameters is allocated in the memory buffer at the end of its data buffer. The limitation is that both a caller and called functions must be aware of the parameter sizes, so it makes it impossible to pass parameters with a variable length. Special helpers are provided for storing and getting parameters form the memory buffer: <a class="el" href="group__buf.html#gaf7e0718a3bb63059a2626ac98b54d65d">ZB_BUF_GET_PARAM()</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa04531caf208df1bd8cc5cc920382f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04531caf208df1bd8cc5cc920382f85">&#9670;&nbsp;</a></span>zb_buf_alloc_left</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_alloc_left</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_alloc_left_func(TRACE_CALL (buf),(size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate space at the beginning of buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">size</td><td>- size to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new data begin </dd></dl>

</div>
</div>
<a id="ga3be3fececb70e81b7541a47e915fafc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3be3fececb70e81b7541a47e915fafc2">&#9670;&nbsp;</a></span>zb_buf_alloc_right</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_alloc_right</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_alloc_right_func(TRACE_CALL (buf),(size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate space at buffer end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">size</td><td>- size to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated data data begin </dd></dl>

</div>
</div>
<a id="gac17ca5d2b3c60c0fb413fa783b6f3d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac17ca5d2b3c60c0fb413fa783b6f3d38">&#9670;&nbsp;</a></span>zb_buf_alloc_tail</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_alloc_tail</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_alloc_tail_func(TRACE_CALL (buf),(size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alloc buffer tail of size 'size', initialize by zero.</p>
<p>Usually used to place external information (some parameters) to the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">size</td><td>- requested size. Must met already allocated size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the buffer tail or NULL is buffer has no parameter of such size. </dd></dl>

</div>
</div>
<a id="ga97fe9fcc0124718cc25c3710b752b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97fe9fcc0124718cc25c3710b752b8fd">&#9670;&nbsp;</a></span>zb_buf_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_begin_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return pointer to data stored in buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to beginning of data in buffer </dd></dl>

</div>
</div>
<a id="ga191c257839a606771135a63f5eafd8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga191c257839a606771135a63f5eafd8a0">&#9670;&nbsp;</a></span>zb_buf_copy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_copy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dst_buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src_buf&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_copy_func(TRACE_CALL (dst_buf),(src_buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one buffer to another </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_buf</td><td>- destination buffer </td></tr>
    <tr><td class="paramname">src_buf</td><td>- source buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa14b3e06193b3dfc9da25717294bc60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa14b3e06193b3dfc9da25717294bc60d">&#9670;&nbsp;</a></span>ZB_BUF_COPY_FLAG_APS_PAYLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_BUF_COPY_FLAG_APS_PAYLOAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                  \</div>
<div class="line">    if ((<a class="code" href="group__buf.html#ga0adf98232d17ed70ea6c38e545d97fa2">zb_buf_flags_get</a>((src)) &amp; <a class="code" href="group__buf.html#ga0bd3894cea7e4ef4fe70fb12f5816b20">ZB_BUF_HAS_APS_PAYLOAD</a>) != 0U)       \</div>
<div class="line">    {                                                            \</div>
<div class="line">      zb_buf_flags_or((dst), <a class="code" href="group__buf.html#ga0bd3894cea7e4ef4fe70fb12f5816b20">ZB_BUF_HAS_APS_PAYLOAD</a>);            \</div>
<div class="line">                                                                        \</div>
<div class="line">      if ((<a class="code" href="group__buf.html#ga0adf98232d17ed70ea6c38e545d97fa2">zb_buf_flags_get</a>((src)) &amp; <a class="code" href="group__buf.html#gae95514c452ade7c8854d51200e488bd8">ZB_BUF_HAS_APS_USER_PAYLOAD</a>) != 0U)\</div>
<div class="line">      {                                                                 \</div>
<div class="line">        zb_buf_flags_or((dst), <a class="code" href="group__buf.html#gae95514c452ade7c8854d51200e488bd8">ZB_BUF_HAS_APS_USER_PAYLOAD</a>);            \</div>
<div class="line">      }                                                                 \</div>
<div class="line">    }                                                            \</div>
<div class="line">  } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1a650530bd2e6d2486a5017b885ff292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a650530bd2e6d2486a5017b885ff292">&#9670;&nbsp;</a></span>zb_buf_cut_left</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_cut_left</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_cut_left_func(TRACE_CALL (buf),(size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cut space at the beginning of buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">size</td><td>- size to cut </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new data begin </dd></dl>

</div>
</div>
<a id="ga68fc67e31e64f6549df59ae20ac0af3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68fc67e31e64f6549df59ae20ac0af3e">&#9670;&nbsp;</a></span>zb_buf_cut_right</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_cut_right</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_cut_right_func(TRACE_CALL (buf),(size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cut space at the end of buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">size</td><td>- size to cut </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c884c4d660daa357eb208ca010e9e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c884c4d660daa357eb208ca010e9e56">&#9670;&nbsp;</a></span>zb_buf_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_end_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return pointer to the data section end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first byte after data in the buffer </dd></dl>

</div>
</div>
<a id="gaf1b2d67c201a1d1712d29eee6cc40541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1b2d67c201a1d1712d29eee6cc40541">&#9670;&nbsp;</a></span>zb_buf_flags_clr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_flags_clr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_flags_clr_func(TRACE_CALL (buf),(mask))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear buffer' flags by mask by doing flags = flags &amp; ~mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">mask</td><td>- value to be cleared from the flags - </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__buf.html#buf_flags_bm">buf_flags_bm</a> </dd></dl>

</div>
</div>
<a id="gaa797eb92f12ff524afbf944be0b70db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa797eb92f12ff524afbf944be0b70db0">&#9670;&nbsp;</a></span>zb_buf_flags_clr_encr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_flags_clr_encr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_flags_clr_encr_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear buffer's flags related to encryption</p>
<p>That function calls <a class="el" href="group__buf.html#gaf1b2d67c201a1d1712d29eee6cc40541">zb_buf_flags_clr(buf, ZB_BUF_SECUR_ALL_ENCR)</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0adf98232d17ed70ea6c38e545d97fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0adf98232d17ed70ea6c38e545d97fa2">&#9670;&nbsp;</a></span>zb_buf_flags_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_flags_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_flags_get_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get buffer's flags byte</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>flags value - </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__buf.html#buf_flags_bm">buf_flags_bm</a> </dd></dl>

</div>
</div>
<a id="ga15c8cb7cd6d9de2c9463640086558864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c8cb7cd6d9de2c9463640086558864">&#9670;&nbsp;</a></span>zb_buf_flags_or</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_flags_or</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_flags_or_func(TRACE_CALL (buf),(val))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add bits to the buffer's flags</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">val</td><td>- value to be ORed with buffer' flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga788a473df6d535c19f5da0d142d4fa01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga788a473df6d535c19f5da0d142d4fa01">&#9670;&nbsp;</a></span>zb_buf_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_free_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free packet buffer and put it into free list. </p>
<p>Can be called from the main loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga252f09a403d23347b2d4987a4d8d1833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga252f09a403d23347b2d4987a4d8d1833">&#9670;&nbsp;</a></span>zb_buf_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_get_func(TRACE_CALL (is_in), (max_size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronous buffer allocation. If no buffers available, does not block. Note: this is low-level API. Usually user calls blocked alloc API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_in</td><td>if ZB_TRUE, allocate IN buffer, else allocate OUT buffer </td></tr>
    <tr><td class="paramname">max_size</td><td>required maximum buffer payload size (in bytes). It can be bigger or smaller than the default buffer size. Depending on the specific value, the buffer pool may decide to use a fraction of buffer or long buffers. Special value 0 means "single default buffer". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer ID or ZB_BUF_INVALID if no buffers available </dd></dl>

</div>
</div>
<a id="ga480eed47d5b538029aefd501e011d97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga480eed47d5b538029aefd501e011d97e">&#9670;&nbsp;</a></span>zb_buf_get_any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_any</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_get_any_func(TRACE_CALL_VOID)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate IN or OUT buffer balancing @ of allocated IN and OUT</p>
<p>To be used at ZBOSS init time. </p>

</div>
</div>
<a id="gaafb1da2b85a931aa24a6c5272359baf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafb1da2b85a931aa24a6c5272359baf4">&#9670;&nbsp;</a></span>zb_buf_get_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_get_handle_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get 'handle' field of the buffer's header</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle field value </dd></dl>

</div>
</div>
<a id="gad941f68ff2866420c96548c426e085f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad941f68ff2866420c96548c426e085f5">&#9670;&nbsp;</a></span>zb_buf_get_hipri</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_hipri</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_get_hipri_func(TRACE_CALL (a))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronous allocation of the high-priority buffer </p>

</div>
</div>
<a id="gad0f373a65f012c04317b6a602823e2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0f373a65f012c04317b6a602823e2aa">&#9670;&nbsp;</a></span>zb_buf_get_in_delayed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_in_delayed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">callback</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_get_in_delayed_func(TRACE_CALL (callback))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate IN buffer, call a callback when the buffer is available. </p>
<p>Use default buffer size _func(alloc single standard buffer). If buffer is available, schedules callback for execution immediately. If no buffers are available now, schedule callback later, when buffer will be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- callback to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RET_OK or error code. </dd></dl>

</div>
</div>
<a id="ga2ca8f9478335d866bc798676906f18f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca8f9478335d866bc798676906f18f0">&#9670;&nbsp;</a></span>zb_buf_get_in_delayed_ext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_in_delayed_ext</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">callback, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_get_in_delayed_ext_func(TRACE_CALL (callback),(arg),(max_size))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate IN buffer, call a callback when the buffer is available. </p>
<p>If buffer is available, schedules callback for execution immediately. If no buffers are available now, schedule callback later, when buffer will be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- callback to call. </td></tr>
    <tr><td class="paramname">arg</td><td>- second argument for a callback </td></tr>
    <tr><td class="paramname">max_size</td><td>required maximum buffer payload size (in bytes). The buffer payload size is the sum of both data and parameters, so the max_size parameter should reflect this. It can be bigger or smaller than the default buffer size. Depending on the specific value, the buffer pool may decide to use a fraction of buffer or long buffers. If the value is set to 0, the payload size will be equal to the size of a single default buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RET_OK if allocation has successfully scheduled. RET_ERROR if there is no room to schedule buffer allocation. RET_OUT_OF_RANGE if buffer with such payload size can't be allocated. </dd></dl>

</div>
</div>
<a id="gabd34d85cc79b8c0712f69cd4a86ed392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd34d85cc79b8c0712f69cd4a86ed392">&#9670;&nbsp;</a></span>zb_buf_get_max_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_max_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_get_max_size_func(TRACE_CALL (a))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return maximum data size for that buffer. </p>

</div>
</div>
<a id="ga1837a0e5af1ed402ca3b84d526f4856b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1837a0e5af1ed402ca3b84d526f4856b">&#9670;&nbsp;</a></span>zb_buf_get_out</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_out</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_get_out_func(TRACE_CALL_VOID)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate OUT buffer of the default size. </p>

</div>
</div>
<a id="ga284f25d25ef8a911d00dc79bea80ce42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga284f25d25ef8a911d00dc79bea80ce42">&#9670;&nbsp;</a></span>zb_buf_get_out_delayed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_out_delayed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">callback</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_get_out_delayed_func(TRACE_CALL (callback))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate OUT buffer, call a callback when the buffer is available. </p>
<p>Use default buffer size _func(alloc single standard buffer). If buffer is available, schedules callback for execution immediately. If no buffers are available now, schedule callback later, when buffer will be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- callback to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RET_OK or error code. </dd></dl>

</div>
</div>
<a id="ga3e1aadf51fc1f01efe2663c442bc1a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e1aadf51fc1f01efe2663c442bc1a73">&#9670;&nbsp;</a></span>zb_buf_get_out_delayed_ext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_out_delayed_ext</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">callback, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_get_out_delayed_ext_func(TRACE_CALL (callback),(arg),(max_size))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate OUT buffer, call a callback when the buffer is available. </p>
<p>If buffer is available, schedules callback for execution immediately. If no buffers are available now, schedule callback later, when buffer will be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- callback to call. </td></tr>
    <tr><td class="paramname">arg</td><td>- second argument for a callback </td></tr>
    <tr><td class="paramname">max_size</td><td>- required maximum buffer payload size (in bytes). The buffer payload size is the sum of both data and parameters, so the max_size parameter should reflect this. It can be bigger or smaller than the default buffer size. Depending on the specific value, the buffer pool may decide to use a fraction of buffer or long buffers. If the value is set to 0, the payload size will be equal to the size of a single default buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RET_OK if allocation has successfully scheduled. RET_ERROR if there is no room to schedule buffer allocation. RET_OUT_OF_RANGE if buffer with such payload size can't be allocated. </dd></dl>

</div>
</div>
<a id="gaf7e0718a3bb63059a2626ac98b54d65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7e0718a3bb63059a2626ac98b54d65d">&#9670;&nbsp;</a></span>ZB_BUF_GET_PARAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_BUF_GET_PARAM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((type *)zb_buf_get_tail_func(TRACE_CALL (buf), sizeof(type)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get buffer tail of size sizeof(type)</p>
<p>Usually used to place external information _func(some parameters) to the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- data type that will be placed at the buffer end</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the buffer tail casted to _func(type*)</dd></dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> device_ieee_addr_req(<a class="code" href="group__base__types.html#gaa82a9657ef11a3947586065cf8066256">zb_uint8_t</a> param, <a class="code" href="group__base__types.html#ga83793366ad4d54e8b65840d82a751498">zb_uint16_t</a> dev_idx)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="group__buf.html#ga72fb48e56b8e7f4b0cf12d12bd491b3b">zb_bufid_t</a> buf = param;</div>
<div class="line">  <a class="code" href="structzb__zdo__ieee__addr__req__param__s.html">zb_zdo_ieee_addr_req_param_t</a> *req_param;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (dev_idx != ERL_GW_INVALID_DEV_INDEX)</div>
<div class="line">  {</div>
<div class="line">    req_param = <a class="code" href="group__buf.html#gaf7e0718a3bb63059a2626ac98b54d65d">ZB_BUF_GET_PARAM</a>(buf, <a class="code" href="structzb__zdo__ieee__addr__req__param__s.html">zb_zdo_ieee_addr_req_param_t</a>);</div>
<div class="line"> </div>
<div class="line">    req_param-&gt;<a class="code" href="structzb__zdo__ieee__addr__req__param__s.html#a487455b267bb9320a6b2f64faa7973a3">nwk_addr</a> = g_device_ctx.devices[dev_idx].short_addr;</div>
<div class="line">    req_param-&gt;<a class="code" href="structzb__zdo__ieee__addr__req__param__s.html#a2183926eb6afdecf05f137ced6133851">dst_addr</a> = req_param-&gt;<a class="code" href="structzb__zdo__ieee__addr__req__param__s.html#a487455b267bb9320a6b2f64faa7973a3">nwk_addr</a>;</div>
<div class="line">    req_param-&gt;<a class="code" href="structzb__zdo__ieee__addr__req__param__s.html#a9df2411ef233519fa22a4599411b9fbb">start_index</a> = 0;</div>
<div class="line">    req_param-&gt;<a class="code" href="structzb__zdo__ieee__addr__req__param__s.html#aba468984beb0d79d98acb2948731f486">request_type</a> = 0;</div>
<div class="line">    <a class="code" href="group__zdo__addr.html#ga4969feb2657c72591711b3057e44cc81">zb_zdo_ieee_addr_req</a>(buf, device_ieee_addr_req_cb);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="group___z_b___t_r_a_c_e.html#gac857eacf1a904b021246dd0e8dda8a76">TRACE_MSG</a>(TRACE_APP2, <span class="stringliteral">&quot;No devices in discovery state were found!&quot;</span>, (FMT__0));</div>
<div class="line">    <a class="code" href="group__buf.html#ga788a473df6d535c19f5da0d142d4fa01">zb_buf_free</a>(buf);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga17d85461a3ccc58a225d62a0b80affab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17d85461a3ccc58a225d62a0b80affab">&#9670;&nbsp;</a></span>zb_buf_get_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_status</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_get_status_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get 'status' field of the buffer's header</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status field value </dd></dl>

</div>
</div>
<a id="ga3b2b3e1cb6505be4c03235fc5467ebdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b2b3e1cb6505be4c03235fc5467ebdf">&#9670;&nbsp;</a></span>zb_buf_get_tail</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_get_tail</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_get_tail_func(TRACE_CALL (buf),(size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get or allocate buffer tail of size 'size'. Do not initialize.</p>
<p>Usually used to get or place external information (some parameters) to the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">size</td><td>- requested size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the buffer tail </dd></dl>

</div>
</div>
<a id="ga0bd3894cea7e4ef4fe70fb12f5816b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bd3894cea7e4ef4fe70fb12f5816b20">&#9670;&nbsp;</a></span>ZB_BUF_HAS_APS_PAYLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_BUF_HAS_APS_PAYLOAD&#160;&#160;&#160;(1U &lt;&lt; 6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to indicate whether the buffer contains any APS payload </p>

</div>
</div>
<a id="gae95514c452ade7c8854d51200e488bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae95514c452ade7c8854d51200e488bd8">&#9670;&nbsp;</a></span>ZB_BUF_HAS_APS_USER_PAYLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_BUF_HAS_APS_USER_PAYLOAD&#160;&#160;&#160;(1U &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to indicate whether the buffer contains APS user payload </p>

</div>
</div>
<a id="ga71af155e981aa06d5a56db6b46d8cc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71af155e981aa06d5a56db6b46d8cc7c">&#9670;&nbsp;</a></span>zb_buf_initial_alloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_initial_alloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_initial_alloc_func(TRACE_CALL (buf),(size))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial data space allocation in buffer. </p>
<p>Allocate space in the buffer center (keep space in both buffer head and tail). Use it at upper layers before filling buffer by data. Old buffer contents is lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">size</td><td>- size to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to buffer data begin </dd></dl>

</div>
</div>
<a id="ga4c187cf4fb6d5edbbb400bff57f6073e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c187cf4fb6d5edbbb400bff57f6073e">&#9670;&nbsp;</a></span>zb_buf_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_len</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_len_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return current buffer length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of data placed in buffer </dd></dl>

</div>
</div>
<a id="ga15f7d1e99e61284da1fa3ddb7f725450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15f7d1e99e61284da1fa3ddb7f725450">&#9670;&nbsp;</a></span>zb_buf_reuse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_reuse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;zb_buf_reuse_func(TRACE_CALL (buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reuse buffer data space by setting data start and length to 0 and zeroing buffer contents</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the buf data buffer begin </dd></dl>

</div>
</div>
<a id="ga262b53968bed3479e484f4947fed664f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga262b53968bed3479e484f4947fed664f">&#9670;&nbsp;</a></span>ZB_BUF_SECUR_APS_ENCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_BUF_SECUR_APS_ENCR&#160;&#160;&#160;(1U &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>APS encryption. Analyze APS header to define which key to use <br  />
 </p>

</div>
</div>
<a id="ga6dd90dd9cc56c3c01a6b9689abb83eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dd90dd9cc56c3c01a6b9689abb83eec">&#9670;&nbsp;</a></span>ZB_BUF_SECUR_MAC_ENCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_BUF_SECUR_MAC_ENCR&#160;&#160;&#160;(1U &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MAC encryption - for 802.15.4 certification only </p>

</div>
</div>
<a id="ga0f85025383555d0cba148b844aca036c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f85025383555d0cba148b844aca036c">&#9670;&nbsp;</a></span>ZB_BUF_SECUR_NO_ENCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_BUF_SECUR_NO_ENCR&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No encryption <br  />
 </p>

</div>
</div>
<a id="ga1d5f780deaff8d4a19dc54099fd648f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d5f780deaff8d4a19dc54099fd648f6">&#9670;&nbsp;</a></span>ZB_BUF_SECUR_NWK_ENCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_BUF_SECUR_NWK_ENCR&#160;&#160;&#160;(1U &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NWK frame encryption <br  />
 </p>

</div>
</div>
<a id="ga7d4efecce2b42165387bb6672ad51423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d4efecce2b42165387bb6672ad51423">&#9670;&nbsp;</a></span>zb_buf_set_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_set_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_set_handle_func(TRACE_CALL (buf),(handle))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set 'handle' field of the buffer's header</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">handle</td><td>- 'handle' field value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4304fbb18c02bd1a2a3e385e1e9c5bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4304fbb18c02bd1a2a3e385e1e9c5bfb">&#9670;&nbsp;</a></span>zb_buf_set_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zb_buf_set_status</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">status&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;zb_buf_set_status_func(TRACE_CALL (buf), (<a class="el" href="group__base__types.html#ga7bdda62719777b9e47b1d7204669f897">zb_ret_t</a>)(status))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set 'status' field of the buffer's header</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- buffer ID </td></tr>
    <tr><td class="paramname">status</td><td>- new status field value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2b987673c0116e579f4865a328d2e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2b987673c0116e579f4865a328d2e26">&#9670;&nbsp;</a></span>ZB_IN_BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_IN_BUFFER&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In buffer </p>

</div>
</div>
<a id="ga7a7f62c75a26924133e28ea5deda3c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a7f62c75a26924133e28ea5deda3c9d">&#9670;&nbsp;</a></span>ZB_OUT_BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZB_OUT_BUFFER&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out buffer </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab4590df4d3fd9b8f78d33ad87279b8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4590df4d3fd9b8f78d33ad87279b8d8">&#9670;&nbsp;</a></span>zb_buf_flags_bm_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__base__types.html#gaa82a9657ef11a3947586065cf8066256">zb_uint8_t</a> <a class="el" href="group__buf.html#gab4590df4d3fd9b8f78d33ad87279b8d8">zb_buf_flags_bm_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for buffer's internals flags bitmask. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>holds one of <a class="el" href="group__buf.html#buf_flags_bm">buf_flags_bm</a>. Kept only for backward compatibility as <a class="el" href="group__buf.html#buf_flags_bm">buf_flags_bm</a> were declared previously as enum. Can be removed in future releases. </dd></dl>

</div>
</div>
<a id="ga3c4203d3a3dff809f0261423f7ff0c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4203d3a3dff809f0261423f7ff0c5b">&#9670;&nbsp;</a></span>zb_buf_hdr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structzb__buf__hdr__s.html">zb_buf_hdr_s</a> <a class="el" href="group__buf.html#ga3c4203d3a3dff809f0261423f7ff0c5b">zb_buf_hdr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Packet buffer header. </p>

</div>
</div>
<a id="ga4388a287d60e2916569ebe70c16a6ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4388a287d60e2916569ebe70c16a6ddf">&#9670;&nbsp;</a></span>zb_buffer_types_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__base__types.html#gaa82a9657ef11a3947586065cf8066256">zb_uint8_t</a> <a class="el" href="group__buf.html#ga4388a287d60e2916569ebe70c16a6ddf">zb_buffer_types_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for Buffer type (direction). </p>
<p>Holds one of <a class="el" href="group__buf.html#buffer_types">buffer_types</a>. Kept for backward compatibility as <a class="el" href="group__buf.html#buffer_types">buffer_types</a> were declared previously as enum. </p>

</div>
</div>
<a id="ga72fb48e56b8e7f4b0cf12d12bd491b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72fb48e56b8e7f4b0cf12d12bd491b3b">&#9670;&nbsp;</a></span>zb_bufid_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__base__types.html#gaa82a9657ef11a3947586065cf8066256">zb_uint8_t</a> <a class="el" href="group__buf.html#ga72fb48e56b8e7f4b0cf12d12bd491b3b">zb_bufid_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer handler </p>

</div>
</div>
<a id="gaed7bf548ce24f125321f00242d98d7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed7bf548ce24f125321f00242d98d7fa">&#9670;&nbsp;</a></span>zb_leg_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structzb__leg__buf__s.html">zb_leg_buf_s</a> <a class="el" href="group__buf.html#gaed7bf548ce24f125321f00242d98d7fa">zb_leg_buf_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Packet buffer (legacy) </p>

</div>
</div>
<a id="ga276d630a0f90931f8110e7b8e7a45df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga276d630a0f90931f8110e7b8e7a45df7">&#9670;&nbsp;</a></span>zb_mult_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structzb__mult__buf__s.html">zb_mult_buf_s</a> <a class="el" href="group__buf.html#ga276d630a0f90931f8110e7b8e7a45df7">zb_mult_buf_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Packet buffer </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae9221bc9089fcd4be96a28944d0e82d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9221bc9089fcd4be96a28944d0e82d2">&#9670;&nbsp;</a></span>zb_buf_get_mac_rx_need()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a> zb_buf_get_mac_rx_need </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get "mac needs more buffers" flag.</p>
<p>To be used internally by ZBOSS.</p>
<dl class="section return"><dt>Returns</dt><dd>"mac needs more buffers" flag value </dd></dl>

</div>
</div>
<a id="gad7855cad80be48f2feac0f61eb53cf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7855cad80be48f2feac0f61eb53cf27">&#9670;&nbsp;</a></span>zb_buf_is_oom_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a> zb_buf_is_oom_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if buffer pool is in Out Of Memory (OOM) state</p>
<dl class="section return"><dt>Returns</dt><dd>ZB_TRUE if ZBOSS is in OOM state </dd></dl>

</div>
</div>
<a id="ga9e8ad9f761a1eccf00ab3eb761a55c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e8ad9f761a1eccf00ab3eb761a55c7e">&#9670;&nbsp;</a></span>zb_buf_memory_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a> zb_buf_memory_low </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if buffer pool is close to Out Of Memory (OOM) state</p>
<dl class="section return"><dt>Returns</dt><dd>ZB_TRUE if ZBOSS is nearly in OOM state </dd></dl>

</div>
</div>
<a id="ga390b0c8500e8d2ac8885ffdfe97493d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga390b0c8500e8d2ac8885ffdfe97493d6">&#9670;&nbsp;</a></span>zb_buf_oom_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zb_buf_oom_trace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trace buffer statistics into ZBOSS trace </p>

</div>
</div>
<a id="ga98f8ca54988786ec13015435abae6f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98f8ca54988786ec13015435abae6f9e">&#9670;&nbsp;</a></span>zb_buf_set_mac_rx_need()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zb_buf_set_mac_rx_need </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__base__types.html#gac0098c2e9d8011bdc1ae2cd1d81c4598">zb_bool_t</a>&#160;</td>
          <td class="paramname"><em>needs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set or reset "mac needs more buffers" flag.</p>
<p>To be used internally by ZBOSS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needs</td><td>- new "mac needs more buffers" flag value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__buf_html_ga0bd3894cea7e4ef4fe70fb12f5816b20"><div class="ttname"><a href="group__buf.html#ga0bd3894cea7e4ef4fe70fb12f5816b20">ZB_BUF_HAS_APS_PAYLOAD</a></div><div class="ttdeci">#define ZB_BUF_HAS_APS_PAYLOAD</div><div class="ttdef"><b>Definition:</b> zboss_api_buf.h:508</div></div>
<div class="ttc" id="agroup__base__types_html_gaa82a9657ef11a3947586065cf8066256"><div class="ttname"><a href="group__base__types.html#gaa82a9657ef11a3947586065cf8066256">zb_uint8_t</a></div><div class="ttdeci">unsigned char zb_uint8_t</div><div class="ttdoc">Project-local 1-byte unsigned int type.</div><div class="ttdef"><b>Definition:</b> zb_types.h:147</div></div>
<div class="ttc" id="agroup___z_b___t_r_a_c_e_html_gac857eacf1a904b021246dd0e8dda8a76"><div class="ttname"><a href="group___z_b___t_r_a_c_e.html#gac857eacf1a904b021246dd0e8dda8a76">TRACE_MSG</a></div><div class="ttdeci">#define TRACE_MSG(lm, fmts, args)</div><div class="ttdoc">Put trace output.</div><div class="ttdef"><b>Definition:</b> zb_trace.h:369</div></div>
<div class="ttc" id="astructzb__zdo__ieee__addr__req__param__s_html_a2183926eb6afdecf05f137ced6133851"><div class="ttname"><a href="structzb__zdo__ieee__addr__req__param__s.html#a2183926eb6afdecf05f137ced6133851">zb_zdo_ieee_addr_req_param_s::dst_addr</a></div><div class="ttdeci">zb_uint16_t dst_addr</div><div class="ttdef"><b>Definition:</b> zboss_api_zdo.h:1714</div></div>
<div class="ttc" id="astructzb__zdo__ieee__addr__req__param__s_html_a9df2411ef233519fa22a4599411b9fbb"><div class="ttname"><a href="structzb__zdo__ieee__addr__req__param__s.html#a9df2411ef233519fa22a4599411b9fbb">zb_zdo_ieee_addr_req_param_s::start_index</a></div><div class="ttdeci">zb_uint8_t start_index</div><div class="ttdef"><b>Definition:</b> zboss_api_zdo.h:1720</div></div>
<div class="ttc" id="astructzb__zdo__ieee__addr__req__param__s_html_aba468984beb0d79d98acb2948731f486"><div class="ttname"><a href="structzb__zdo__ieee__addr__req__param__s.html#aba468984beb0d79d98acb2948731f486">zb_zdo_ieee_addr_req_param_s::request_type</a></div><div class="ttdeci">zb_uint8_t request_type</div><div class="ttdef"><b>Definition:</b> zboss_api_zdo.h:1717</div></div>
<div class="ttc" id="agroup__zdo__addr_html_ga4969feb2657c72591711b3057e44cc81"><div class="ttname"><a href="group__zdo__addr.html#ga4969feb2657c72591711b3057e44cc81">zb_zdo_ieee_addr_req</a></div><div class="ttdeci">zb_uint8_t zb_zdo_ieee_addr_req(zb_uint8_t param, zb_callback_t cb)</div><div class="ttdoc">IEEE_addr_req primitive.</div></div>
<div class="ttc" id="agroup__buf_html_gaf7e0718a3bb63059a2626ac98b54d65d"><div class="ttname"><a href="group__buf.html#gaf7e0718a3bb63059a2626ac98b54d65d">ZB_BUF_GET_PARAM</a></div><div class="ttdeci">#define ZB_BUF_GET_PARAM(buf, type)</div><div class="ttdef"><b>Definition:</b> zboss_api_buf.h:457</div></div>
<div class="ttc" id="astructzb__zdo__ieee__addr__req__param__s_html"><div class="ttname"><a href="structzb__zdo__ieee__addr__req__param__s.html">zb_zdo_ieee_addr_req_param_s</a></div><div class="ttdoc">Parameters for ieee_addr_req command.</div><div class="ttdef"><b>Definition:</b> zboss_api_zdo.h:1712</div></div>
<div class="ttc" id="agroup__buf_html_ga0adf98232d17ed70ea6c38e545d97fa2"><div class="ttname"><a href="group__buf.html#ga0adf98232d17ed70ea6c38e545d97fa2">zb_buf_flags_get</a></div><div class="ttdeci">#define zb_buf_flags_get(buf)</div><div class="ttdef"><b>Definition:</b> zboss_api_buf.h:559</div></div>
<div class="ttc" id="agroup__base__types_html_ga83793366ad4d54e8b65840d82a751498"><div class="ttname"><a href="group__base__types.html#ga83793366ad4d54e8b65840d82a751498">zb_uint16_t</a></div><div class="ttdeci">unsigned short zb_uint16_t</div><div class="ttdoc">Project-local 2-byte unsigned int type.</div><div class="ttdef"><b>Definition:</b> zb_types.h:151</div></div>
<div class="ttc" id="agroup__buf_html_gae95514c452ade7c8854d51200e488bd8"><div class="ttname"><a href="group__buf.html#gae95514c452ade7c8854d51200e488bd8">ZB_BUF_HAS_APS_USER_PAYLOAD</a></div><div class="ttdeci">#define ZB_BUF_HAS_APS_USER_PAYLOAD</div><div class="ttdef"><b>Definition:</b> zboss_api_buf.h:509</div></div>
<div class="ttc" id="agroup__buf_html_ga788a473df6d535c19f5da0d142d4fa01"><div class="ttname"><a href="group__buf.html#ga788a473df6d535c19f5da0d142d4fa01">zb_buf_free</a></div><div class="ttdeci">#define zb_buf_free(buf)</div><div class="ttdoc">Free packet buffer and put it into free list.</div><div class="ttdef"><b>Definition:</b> zboss_api_buf.h:344</div></div>
<div class="ttc" id="agroup__buf_html_ga72fb48e56b8e7f4b0cf12d12bd491b3b"><div class="ttname"><a href="group__buf.html#ga72fb48e56b8e7f4b0cf12d12bd491b3b">zb_bufid_t</a></div><div class="ttdeci">zb_uint8_t zb_bufid_t</div><div class="ttdef"><b>Definition:</b> zboss_api_buf.h:178</div></div>
<div class="ttc" id="astructzb__zdo__ieee__addr__req__param__s_html_a487455b267bb9320a6b2f64faa7973a3"><div class="ttname"><a href="structzb__zdo__ieee__addr__req__param__s.html#a487455b267bb9320a6b2f64faa7973a3">zb_zdo_ieee_addr_req_param_s::nwk_addr</a></div><div class="ttdeci">zb_uint16_t nwk_addr</div><div class="ttdef"><b>Definition:</b> zboss_api_zdo.h:1715</div></div>
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Thu Nov 14 2024" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>
